[ { "title": "白夜行读后感", "url": "/posts/%E7%99%BD%E5%A4%9C%E8%A1%8C%E8%AF%BB%E5%90%8E%E6%84%9F/", "categories": "观/读后感", "tags": "东野圭吾", "date": "2022-03-04 21:50:00 +0800", "snippet": "文章先开始介绍了一宗谋杀案，桐原良介被谋杀了，而他老婆以前是做妓女的，和他的店铺的店长有点可疑，但是又没有什么特别的证据，他有一个儿子桐原亮司，然后警方又找到了他临死前去的地方，也就是西本文代家，西本文代有个女儿，自己也是那种高冷美人，老公七年前就死了，家里比较平穷，有一个很可爱很聪明的女儿，西本雪慧。第二章讲的是秋吉雄一是个玩摄影的穷小子，他被派去偷拍雪穗，他有一个好基友菊池文彦，然后这边的雪穗已经被收养了，改名问唐泽雪穗，她的一个闺蜜江利子很羡慕她，不过也听到了一些和她有关的传闻，很快，另外一个人都子被人打晕遭到威胁，有人怀疑过秋吉、文彦，还有秋吉出卖过一个人名字叫做 xx，被打了一顿。桐原亮司，也就是第一章受害人的孩子，亮司性格比较沉闷，话也比较少但是居然和雪穗关系密切，令人不解。第三章三个高中生被桐原亮司拉去做男妓，他自己也是，还是多人运动。。。然后有个女的还死了，惊动了警察，然后亮司勾引一个公司的会计去偷了游戏程序，然后成立公司，卖盗版游戏程序赚钱雪穗原本姓西本，各种科目都很优秀，出了数学，雪穗从小就心机重，跑到唐泽女士家里玩，文中暗示雪穗母亲中煤气死了，她被唐泽收养了，改名唐泽，为讨好唐泽女士，学会了插花和茶道，本人很优雅，这里有个小细节，她朋友失恋要自杀，她对老师说“ 她真的太傻了，不过就是男人嘛，何必这样寻死”，说明她对男人很有一套读完了，简直是颠覆了我的三观，亮司和雪慧两个人都是那种非常努力，非常上进，可以说都是很聪明很努力的人物，雪慧后来跻身上流社会，但是他们的“成功”是向罪恶的深渊一步步堕落的，有多成功就有多么可恨，他们的亲人朋友全都死了，-这种反差真的很让人震撼！让人唏嘘不已，最后结局以亮司自杀，雪慧头也不回而结束，哇！果然，东野奎吾真的是厉害，这种小说也能写出来，不过这里面也反应出了日本的文化在里面，性、恋童癖，妓女，男妓，拜金，出轨，让人对日本的社会有所了解，也是对社会现象的一种讽刺。正本小说讲的故事比较可怕，文中没有正面描写过，但是应该是亮司碰到了自己的父亲侵犯雪穗，然后把自己老爸给杀了，由于这件事，导致了后续的一系列连锁反应，亮司和雪穗这个时候联系到一起了，雪穗一开始就很有心机，老妈煤气中毒死了，被优雅的唐泽女士收养，改名唐泽雪穗，靠亮司搞自己的闺蜜，巴结上富二代，后面终结养母生命，加入豪门，跻身上流社会。而这边亮司高中时代当男妓，并且成功套路了他的同学，还勾引一个会计偷游戏程序的源码，然后开公司卖游戏赚钱，提雪穗除掉任何挡路的人，可以不择手段。可惜的是雪穗把他当做上位的唯一障碍，亮司自杀后，雪穗头也不回。经典语句:雪穗对夏美说:“我的天空里没有太阳总是黑夜，但并不暗，因为有东西代替了太阳，虽然没有太阳那么明亮，但是对我来说已经足够，凭借着这份光，我便能把黑夜当成白天.亮司的梦想:“在白天走路。唐泽雪穗对老师说：“她真的太傻了，不过就是男人嘛，何必这样寻死”亮司： 我只能卖我能卖的东西。" }, { "title": "二分查找-BinraySearch总结", "url": "/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-binraysearch%E6%80%BB%E7%BB%93/", "categories": "", "tags": "", "date": "2022-01-04 22:53:00 +0800", "snippet": "前言二分查找(Binary Search)是一种从有序数组中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。 如果在某一步骤数组为空，则代表找不到。算法实现(python)while 循环写法def binary_search(nums: List[int], target: int): left = 0 right = len(nums)-1 while left &amp;lt;= right: mid = left + (right-left) // 2 if target &amp;lt; nums[mid]: right = mid-1 elif target &amp;gt; nums[mid]: left = mid+1 else: return mid return -1递归写法def binary_search_recursion(nums: List[int], target: int): def binary_search(left: int, right: int): if right &amp;gt;= left: mid = left + (right - left) // 2 if target &amp;lt; nums[mid]: binary_search(left, mid-1) elif target &amp;gt; nums[mid]: binary_search(mid+1, right) else: return mid return -1 return binary_search(0, len(nums)-1)二分查找的注意事项 条件语句left&amp;lt;=right,等于号不能掉，否则情况出现的不全 当taget&amp;lt;nums[mid]的时候，一定要将 mid-1 赋值给 right，不能直接将 mid 赋值给 right，同样赋值给 left 的时候也是一样二分查找的变种TODO" }, { "title": "排序算法总结", "url": "/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/", "categories": "数据结构与算法", "tags": "排序", "date": "2022-01-02 13:52:00 +0800", "snippet": "排序算法排序算法是计算机科学中最基础的算法之一，它们将一组元素按照一定的规则重新排列。下面是一些常见的排序算法： 冒泡排序（Bubble Sort）：比较相邻的两个元素，如果前一个比后一个大，就交换它们的位置。重复这个过程，直到没有任何一对数字需要交换为止。 插入排序（Insertion Sort）：将数组分为已排序区间和未排序区间，初始时已排序区间只有一个元素，每次将未排序区间中的一个元素插入到已排序区间中的正确位置。 选择排序（Selection Sort）：每次从未排序区间中找到最小（或最大）的元素，将其放到已排序区间的末尾。 快速排序（Quick Sort）：选择一个基准元素，将小于它的元素放在左边，大于它的元素放在右边，然后对它左右两边的子数组分别递归地进行同样的操作。 归并排序（Merge Sort）：将数组分成两个子数组，分别递归地进行排序，然后将两个子数组合并成一个有序的数组。 堆排序（Heap Sort）：将数组构建成一个堆，然后不断将堆顶元素与堆底元素交换，并重新调整堆，直到整个数组变成有序的。 希尔排序（Shell Sort）：将数组按照一定的间隔分组，对每组进行插入排序，然后逐步缩小间隔直到变为 1，最后进行一次插入排序。 下表列出了以上排序算法的时间复杂度和空间复杂度，以及使用场景： 算法名称 时间复杂度（平均） 时间复杂度（最坏） 时间复杂度（最好） 空间复杂度 稳定性 使用场景 冒泡排序 O(n^2) O(n^2) O(n) O(1) 稳定 适用于小数据量或已经接近有序的数据 插入排序 O(n^2) O(n^2) O(n) O(1) 稳定 适用于小数据量或已经接近有序的数据 选择排序 O(n^2) O(n^2) O(n^2) O(1) 不稳定 适用于小数据量 快速排序 O(nlogn) O(n^2) O(nlogn) O(logn)~O(n) 不稳定 适用于中等大小数据量 归并排序 O(nlogn) O(nlogn) O(nlogn) O(n) 稳定 适用于大数据量 堆排序 O(nlogn) O(nlogn) O(nlogn) O(1) 不稳定 适用于大数据量 希尔排序 O(nlogn)~O(n^2) O(n^2) O(n) O(1) 不稳定 适用于中等大小数据量 注意：时间复杂度中的 n 是指数组的长度。空间复杂度中的 O(logn)~O(n) 表示递归调用所需要的空间，取决于递归深度，最好情况下是 O(logn)，最坏情况下是 O(n)。稳定性指排序算法是否能够保证相等元素的相对顺序不变。冒泡排序下面是使用 TypeScript 实现冒泡排序的代码：function bubbleSort(arr: number[]): number[] { const len = arr.length; for (let i = 0; i &amp;lt; len - 1; i++) { for (let j = 0; j &amp;lt; len - 1 - i; j++) { if (arr[j] &amp;gt; arr[j + 1]) { [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; // 交换元素 } } } return arr;}// 使用示例const arr = [5, 3, 8, 4, 2];const sortedArr = bubbleSort(arr);console.log(sortedArr); // [2, 3, 4, 5, 8]解释： bubbleSort 函数接受一个数字数组作为参数，返回排序后的数组。 内部使用两层循环来实现冒泡排序。外层循环控制排序的轮数，内层循环控制每轮排序中相邻元素的比较和交换。 如果相邻元素的顺序不正确，就交换它们的位置。 最后返回排序后的数组。 插入排序下面是使用 TypeScript 实现插入排序的代码：function insertionSort(arr: number[]): number[] { const len = arr.length; for (let i = 1; i &amp;lt; len; i++) { const temp = arr[i]; let j = i - 1; while (j &amp;gt;= 0 &amp;amp;&amp;amp; arr[j] &amp;gt; temp) { arr[j + 1] = arr[j]; j--; } arr[j + 1] = temp; } return arr;}// 使用示例const arr = [5, 3, 8, 4, 2];const sortedArr = insertionSort(arr);console.log(sortedArr); // [2, 3, 4, 5, 8]解释： insertionSort 函数接受一个数字数组作为参数，返回排序后的数组。 外层循环从数组的第二个元素开始，依次将其插入前面已排序的子数组中。 内层循环从当前元素的前一个元素开始，依次与当前元素比较，如果前一个元素大于当前元素，则将前一个元素后移一位。 当找到第一个小于等于当前元素的元素时，将当前元素插入其后面。 重复执行步骤 2~4，直到整个数组都被排序好。 最后返回排序后的数组。 选择排序下面是使用 TypeScript 实现选择排序的代码：function selectionSort(arr: number[]): number[] { const len = arr.length; for (let i = 0; i &amp;lt; len - 1; i++) { let minIndex = i; for (let j = i + 1; j &amp;lt; len; j++) { if (arr[j] &amp;lt; arr[minIndex]) { minIndex = j; } } if (minIndex !== i) { [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]]; // 交换元素 } } return arr;}// 使用示例const arr = [5, 3, 8, 4, 2];const sortedArr = selectionSort(arr);console.log(sortedArr); // [2, 3, 4, 5, 8]解释： selectionSort 函数接受一个数字数组作为参数，返回排序后的数组。 外层循环从数组的第一个元素开始，依次选择最小的元素并将其与当前元素交换位置。 内层循环从当前元素的下一个元素开始，依次与当前元素比较，找到最小的元素的下标。 如果最小元素的下标不是当前元素的下标，则将这两个元素交换位置。 重复执行步骤 2~4，直到整个数组都被排序好。 最后返回排序后的数组。 快速排序下面是使用 TypeScript 实现快速排序的代码：function quickSort(arr: number[]): number[] { if (arr.length &amp;lt;= 1) { return arr; // 基线条件：数组长度为 0 或 1，直接返回 } const pivot = arr[0]; // 选择第一个元素作为基准值 const leftArr = []; const rightArr = []; for (let i = 1; i &amp;lt; arr.length; i++) { if (arr[i] &amp;lt; pivot) { leftArr.push(arr[i]); } else { rightArr.push(arr[i]); } } return [...quickSort(leftArr), pivot, ...quickSort(rightArr)]; // 递归调用}// 使用示例const arr = [5, 3, 8, 4, 2];const sortedArr = quickSort(arr);console.log(sortedArr); // [2, 3, 4, 5, 8]解释： quickSort 函数接受一个数字数组作为参数，返回排序后的数组。 首先检查数组长度是否为 0 或 1，如果是，则直接返回原数组。这是递归算法的基线条件。 选择数组的第一个元素作为基准值（pivot）。 将数组中剩余的元素分别与基准值比较，小于基准值的元素放入左侧数组（leftArr），大于等于基准值的元素放入右侧数组（rightArr）。 对左侧数组和右侧数组分别递归调用 quickSort 函数，将结果合并。 最后返回合并后的数组。 注意：以上代码中的 number 类型可以根据实际情况替换成其他类型。此外，以上代码实现了简单版本的快速排序，还有其他变种的快速排序算法，例如随机化快速排序、三路快速排序等，可以根据具体情况选择使用。归并排序下面是使用 TypeScript 实现归并排序的代码：function mergeSort(arr: number[]): number[] { if (arr.length &amp;lt;= 1) { return arr; // 基线条件：数组长度为 0 或 1，直接返回 } const mid = Math.floor(arr.length / 2); const leftArr = arr.slice(0, mid); const rightArr = arr.slice(mid); return merge(mergeSort(leftArr), mergeSort(rightArr)); // 递归调用}function merge(leftArr: number[], rightArr: number[]): number[] { const result = []; let leftIndex = 0; let rightIndex = 0; while (leftIndex &amp;lt; leftArr.length &amp;amp;&amp;amp; rightIndex &amp;lt; rightArr.length) { if (leftArr[leftIndex] &amp;lt; rightArr[rightIndex]) { result.push(leftArr[leftIndex]); leftIndex++; } else { result.push(rightArr[rightIndex]); rightIndex++; } } return result.concat(leftArr.slice(leftIndex), rightArr.slice(rightIndex));}// 使用示例const arr = [5, 3, 8, 4, 2];const sortedArr = mergeSort(arr);console.log(sortedArr); // [2, 3, 4, 5, 8]解释： mergeSort 函数接受一个数字数组作为参数，返回排序后的数组。 首先检查数组长度是否为 0 或 1，如果是，则直接返回原数组。这是递归算法的基线条件。 将数组分成两个子数组（leftArr 和 rightArr），分别递归调用 mergeSort 函数。 调用 merge 函数将左侧数组和右侧数组合并成一个数组。 重复执行步骤 2~4，直到整个数组都被排序好。 最后返回排序后的数组。 merge 函数接受两个已排序的数组作为参数，返回一个合并后的已排序数组。 在 merge 函数中，使用两个指针（leftIndex 和 rightIndex）分别指向左侧数组和右侧数组的开头，比较两个指针所指向的元素大小，将较小的元素加入结果数组（result）中。 当其中一个数组被遍历完后，将另一个数组剩余的元素加入结果数组中。 最后返回合并后的已排序数组。 归并排序的时间复杂度为 O(nlogn)，是一种比较高效的排序算法。堆排序下面是使用 TypeScript 实现堆排序的代码：function heapSort(arr: number[]): number[] { buildMaxHeap(arr); // 构建最大堆 for (let i = arr.length - 1; i &amp;gt; 0; i--) { [arr[0], arr[i]] = [arr[i], arr[0]]; // 将堆顶元素与末尾元素交换 maxHeapify(arr, 0, i); // 对剩余元素重新构建最大堆 } return arr;}function buildMaxHeap(arr: number[]): void { const len = arr.length; const lastParentIndex = Math.floor(len / 2) - 1; // 最后一个非叶子节点的下标 for (let i = lastParentIndex; i &amp;gt;= 0; i--) { maxHeapify(arr, i, len); // 对每个非叶子节点进行最大堆化 }}function maxHeapify(arr: number[], index: number, heapSize: number): void { const leftIndex = index * 2 + 1; const rightIndex = index * 2 + 2; let largestIndex = index; if (leftIndex &amp;lt; heapSize &amp;amp;&amp;amp; arr[leftIndex] &amp;gt; arr[largestIndex]) { largestIndex = leftIndex; } if (rightIndex &amp;lt; heapSize &amp;amp;&amp;amp; arr[rightIndex] &amp;gt; arr[largestIndex]) { largestIndex = rightIndex; } if (largestIndex !== index) { [arr[index], arr[largestIndex]] = [arr[largestIndex], arr[index]]; // 交换元素 maxHeapify(arr, largestIndex, heapSize); // 递归调用，对被交换的子树进行最大堆化 }}// 使用示例const arr = [5, 3, 8, 4, 2];const sortedArr = heapSort(arr);console.log(sortedArr); // [2, 3, 4, 5, 8]解释： heapSort 函数接受一个数字数组作为参数，返回排序后的数组。 首先调用 buildMaxHeap 函数构建最大堆。 从数组末尾开始，依次将堆顶元素（最大元素）与末尾元素交换位置。 对剩余的元素重新构建最大堆。 重复执行步骤 3~4，直到整个数组都被排序好。 最后返回排序后的数组。 buildMaxHeap 函数接受一个数字数组作为参数，用于构建最大堆。 首先计算出最后一个非叶子节点的下标。 从最后一个非叶子节点开始，依次对每个非叶子节点进行最大堆化。 maxHeapify 函数接受一个数字数组、一个下标和堆的大小作为参数，用于最大堆化。 首先计算出左右子节点的下标，并将当前节点设为最大节点。 如果左子节点的值比最大节点的值大，则将左子节点设为最大节点。 如果右子节点的值比最大节点的值大，则将右子节点设为最大节点。 如果最大节点不是当前节点，则交换当前节点和最大节点的值，并对被交换的子树进行最大堆化。 重复执行步骤 11~14，直到整个子树都被最大堆化。 堆排序的时间复杂度为 O(nlogn)，是一种比较高效的排序算法。希尔排序下面是使用 TypeScript 实现希尔排序的代码：function shellSort(arr: number[]): number[] { const len = arr.length; let gap = Math.floor(len / 2); // 初始步长 while (gap &amp;gt; 0) { // 插入排序 for (let i = gap; i &amp;lt; len; i++) { const temp = arr[i]; let j = i - gap; while (j &amp;gt;= 0 &amp;amp;&amp;amp; arr[j] &amp;gt; temp) { arr[j + gap] = arr[j]; j -= gap; } arr[j + gap] = temp; } gap = Math.floor(gap / 2); // 缩小步长 } return arr;}// 使用示例const arr = [5, 3, 8, 4, 2];const sortedArr = shellSort(arr);console.log(sortedArr); // [2, 3, 4, 5, 8]解释： shellSort 函数接受一个数字数组作为参数，返回排序后的数组。 首先计算出数组长度和初始步长（通常为数组长度的一半）。 对于每个步长，执行一次插入排序。 插入排序的实现方式与普通插入排序相同，只是将增量值（步长）作为循环变量的步长。 每完成一次插入排序后，将步长缩小为原来的一半。 重复执行步骤 3~5，直到步长为 1。 最后返回排序后的数组。 希尔排序的时间复杂度为 O(nlogn)，是一种比较高效的排序算法。" }, { "title": "设计模式之命令模式", "url": "/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/", "categories": "设计模式", "tags": "命令模式", "date": "2021-06-20 17:44:00 +0800", "snippet": "设计模式之命令模式简介命令模式，将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。命令模式的 UML 类图：Cpp 基本实现#include &amp;lt;iostream&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;list&amp;gt;class Stock{ public: void buy(){ std::cout &amp;lt;&amp;lt;&quot;Name: &quot; &amp;lt;&amp;lt; name&amp;lt;&amp;lt; &quot; Quantity: &quot;&amp;lt;&amp;lt; quantity&amp;lt;&amp;lt;&quot; bought&quot; &amp;lt;&amp;lt;std::endl; } void sell(){ std::cout &amp;lt;&amp;lt;&quot;Name: &quot; &amp;lt;&amp;lt; name&amp;lt;&amp;lt; &quot; Quantity: &quot;&amp;lt;&amp;lt; quantity&amp;lt;&amp;lt;&quot; sold&quot; &amp;lt;&amp;lt;std::endl; } private: std::string name = &quot;abc&quot;; int quantity = 10;};class Order{ public: virtual void execute()=0;};class BuyStock : public Order {private: Stock* stock;public: BuyStock(Stock* abcStock) { stock = abcStock; } void execute() { stock-&amp;gt;buy(); }};class SellStock: public Order{ private: Stock* stock; public: SellStock(Stock* abcSTock){ stock = abcSTock; } void execute() { stock-&amp;gt;sell(); }};class Broker{ private: std::list&amp;lt;Order*&amp;gt; orderList; public: void takeOrder(Order* order){ orderList.push_back(order); } void placeOrder(){ for( auto&amp;amp; order: orderList){ order-&amp;gt;execute(); } orderList.clear(); }};int main(){ Stock* abcStock = new Stock(); BuyStock* buyStockOrder = new BuyStock(abcStock); SellStock* sellStockOrder = new SellStock(abcStock); Broker* broker = new Broker(); broker-&amp;gt;takeOrder(buyStockOrder); broker-&amp;gt;takeOrder(sellStockOrder); broker-&amp;gt;placeOrder(); return 0;}" }, { "title": "cpp-设计模式之单例模式", "url": "/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/", "categories": "设计模式", "tags": "单例模式", "date": "2021-06-17 22:29:37 +0800", "snippet": "设计模式之单例模式单例模式简介单例模式是最简单的模式之一，其目的为保证一个类只有一个实例，并提供一个访问它的全局节点.懒汉式(Lazy Singleton)懒汉式是最基本的单例模式，单例实例会在第一次被使用时才进行初始化，称之为延迟初始化#include &amp;lt;iostream&amp;gt;class Singleton{ public: static Singleton * getInstance(){ if(pInstance == nullptr){ pInstance = new Singleton(); std::cout &amp;lt;&amp;lt; &quot;创建唯一实例&quot; &amp;lt;&amp;lt; std::endl; } return pInstance; }; private: Singleton(){}; //构造函数设计成私有的 static Singleton* pInstance;};Singleton* Singleton::pInstance = nullptr;int main(){ Singleton* obj = Singleton::getInstance(); return 0;}懒汉式会存在问题： 线程不安全的问题. 比如两个线程同时调用了 getInstance，恰巧此时 pInstance 都为 nullptr，那么就会调用两次 new，最简单的方法是加锁 存在内存泄漏问题. 有两种解决方法，一种是使用共享指针，另外一种是使用静态的嵌套类对象 改进版懒汉式：#include &amp;lt;iostream&amp;gt;#include &amp;lt;memory&amp;gt;#include &amp;lt;mutex&amp;gt;class Singleton{ public: static std::shared_ptr&amp;lt;Singleton&amp;gt; getInstance(){ if(pInstance == nullptr){ // doble checked lock std::lock_guard&amp;lt;std::mutex&amp;gt; lock(mutex); if(pInstance == nullptr){ // pInstance = new Singleton(); pInstance = std::shared_ptr&amp;lt;Singleton&amp;gt;(new Singleton); std::cout &amp;lt;&amp;lt; &quot;创建唯一实例&quot; &amp;lt;&amp;lt; std::endl; } } return pInstance; }; private: Singleton(){}; //构造函数设计成私有的 static std::mutex mutex; static std::shared_ptr&amp;lt;Singleton&amp;gt; pInstance;};std::shared_ptr&amp;lt;Singleton&amp;gt; Singleton::pInstance = nullptr;std::mutex Singleton::mutex;int main(){ std::shared_ptr&amp;lt;Singleton&amp;gt; obj = Singleton::getInstance(); return 0;}其优点是使用 shared_ptr，基于 RAII 思想用对象管理资源，当 shared_ptr 析构时，new 出来的对象也会被析构掉。双检锁，double check，使用锁保证线程安全，双检：保证只有当智能指针为空的时候，才会加锁检查，避免每次调用 getInstance 的方法都加锁，浪费锁的开销另外还可以使用 magic static，局部静态变量，这是最推荐的懒汉式实现方法,其思想主要是利用 c++11 的 static 个性，当变量在初始化的时候，并发同时进入声明语句，并发线程将会阻塞等待初始化结束，这就保证了并发线程 在获取静态局部变量的时候一定是初始化过的，所以具有线程安全性。#include &amp;lt;iostream&amp;gt;#include &amp;lt;memory&amp;gt;#include &amp;lt;mutex&amp;gt;class Singleton{ public: static Singleton&amp;amp; getInstance(){ static Singleton pInstance; return pInstance; }; private: Singleton(){ std::cout &amp;lt;&amp;lt; &quot;创建单例模式&quot; &amp;lt;&amp;lt; std::endl; }; //构造函数设计成私有的};int main(){ Singleton obj = Singleton::getInstance(); return 0;}饿汉式(Eager Singleton)饿汉式是指单例实例在程序运行时就被立即执行初始化#include &amp;lt;iostream&amp;gt;#include &amp;lt;memory&amp;gt;#include &amp;lt;mutex&amp;gt;class Singleton{ public: static Singleton&amp;amp; getInstance(){ return pInstance; }; private: Singleton(){ std::cout &amp;lt;&amp;lt; &quot;创建单例模式&quot; &amp;lt;&amp;lt; std::endl; }; //构造函数设计成私有的 static Singleton pInstance;};Singleton Singleton::pInstance;int main(){ Singleton obj = Singleton::getInstance(); return 0;}参考链接：https://www.jianshu.com/p/b71b26c5165b" }, { "title": "Cpp设计模式之工厂模式", "url": "/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/", "categories": "设计模式", "tags": "工厂模式", "date": "2021-06-10 22:11:59 +0800", "snippet": "工厂模式工厂模式介绍工厂模式属于创建型模式，大致可以分为三类，简单工厂模式、工厂方法模式、抽象工厂模式。听上去差不多，都是工厂模式。下面一个个介绍，首先介绍简单工厂模式，它的主要特点是需要在工厂类中做判断，从而创造相应的产品。当增加新的产品时，就需要修改工厂类。有点抽象，举个例子就明白了。有一家生产处理器核的厂家，它只有一个工厂，能够生产两种型号的处理器核。客户需要什么样的处理器核，一定要显示地告诉生产工厂。下面给出一种实现方案。C++实现简单工厂模式若有工厂模式如下图：)使用 c++实现应该为：#include &amp;lt;iostream&amp;gt;class Shape{public: // 纯虚函数 virtual void draw();};class Circle : public Shape{ void draw() { std::cout &amp;lt;&amp;lt; &quot;Draw Circle&quot; &amp;lt;&amp;lt; std::endl; }};class Square : public Shape{ void draw() { std::cout &amp;lt;&amp;lt; &quot;Draw Square&quot; &amp;lt;&amp;lt; std::endl; }};class Rectangle : public Shape{ void draw() { std::cout &amp;lt;&amp;lt; &quot;Draw Rectangle&quot; &amp;lt;&amp;lt; std::endl; }};class ShapeFactory{public: Shape *getShape(std::string shapeType) { // if (shapeType == nullptr){ // return nullptr // } if (shapeType == &quot;Circle&quot;) { return new Circle(); } else if (shapeType == &quot;Square&quot;) { return new Square(); } else if (shapeType == &quot;Rectangle&quot;) { return new Rectangle(); } else { return nullptr; } }};int main(){ return 0;}C++实现抽象工厂模式工厂方法模式也有缺点，每增加一种产品，就需要增加一个对象的工厂。如果增加多个产品就要设定多个工厂。在 C++实现中，就是要定义一个个的工厂类。显然，相比简单工厂模式，抽象工厂方法模式需要更多的类定义。抽象工厂模式就是为了解决这个问题而产生的，它的定义为提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。例如这里定义了一个抽象工厂类，可以直接返回 Shape 工厂或者 Color 工厂，而无需关注工厂内部的实现。具体的 C++代码如下：#include &amp;lt;iostream&amp;gt;class Shape{public: virtual void draw() = 0;};class Color{public: virtual void fill() = 0;};class AbstractFactory{public: virtual Shape *getShape(std::string shapeType) { return nullptr; }; virtual Color *getColor(std::string colorType) { return nullptr; };};class Circle : public Shape{ void draw() { std::cout &amp;lt;&amp;lt; &quot;Draw Square&quot; &amp;lt;&amp;lt; std::endl; }};class Square : public Shape{ void draw() { std::cout &amp;lt;&amp;lt; &quot;Draw Square&quot; &amp;lt;&amp;lt; std::endl; }};class Rectangle : public Shape{ void draw() { std::cout &amp;lt;&amp;lt; &quot;Draw Rectangle&quot; &amp;lt;&amp;lt; std::endl; }};class Red : public Color{ void fill() { std::cout &amp;lt;&amp;lt; &quot;Fill Red&quot; &amp;lt;&amp;lt; std::endl; }};class Green : public Color{ void fill() { std::cout &amp;lt;&amp;lt; &quot;Fill Green&quot; &amp;lt;&amp;lt; std::endl; }};class Blue : public Color{ void fill() { std::cout &amp;lt;&amp;lt; &quot;Fill Blue&quot; &amp;lt;&amp;lt; std::endl; }};class ShapeFactory : public AbstractFactory{ Shape *getShape(std::string shapeType) { if (shapeType == &quot;Circle&quot;) { return new Circle(); } else if (shapeType == &quot;Rectangle&quot;) { return new Rectangle(); } else if (shapeType == &quot;Square&quot;) { return new Square(); } else { return nullptr; } };};class ColorFactory : public AbstractFactory{ Color *getColor(std::string colorType) { if (colorType == &quot;Red&quot;) { return new Red(); } else if (colorType == &quot;Blue&quot;) { return new Blue(); } else if (colorType == &quot;Green&quot;) { return new Green(); } else { return nullptr; } }};class FactoryProducer{public: AbstractFactory *getFactory(std::string factoryType) { if (factoryType == &quot;Shape&quot;) { return new ShapeFactory(); } else if (factoryType == &quot;Color&quot;) { return new ColorFactory(); } else { return nullptr; } };};int main(){ auto demo = new FactoryProducer(); AbstractFactory *ShapeFactory = demo-&amp;gt;getFactory(&quot;Shape&quot;); Shape *myshape = ShapeFactory-&amp;gt;getShape(&quot;Circle&quot;); myshape-&amp;gt;draw(); Shape *myshape2 = ShapeFactory-&amp;gt;getShape(&quot;Square&quot;); myshape2-&amp;gt;draw(); Shape *myshape3 = ShapeFactory-&amp;gt;getShape(&quot;Square&quot;); myshape3-&amp;gt;draw(); AbstractFactory *ColorFactory = demo-&amp;gt;getFactory(&quot;Color&quot;); Color *myColor = ColorFactory-&amp;gt;getColor(&quot;Red&quot;); myColor-&amp;gt;fill(); Color *myColor2 = ColorFactory-&amp;gt;getColor(&quot;Blue&quot;); myColor2-&amp;gt;fill(); Color *myColor3 = ColorFactory-&amp;gt;getColor(&quot;Green&quot;); myColor3-&amp;gt;fill();}参考链接https://www.runoob.com/design-pattern/factory-pattern.htmlhttps://blog.csdn.net/wuzhekai1985/article/details/6660462" }, { "title": "python学习笔记", "url": "/posts/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/", "categories": "编程语言", "tags": "python", "date": "2020-07-27 21:23:47 +0800", "snippet": "思维导图笔记如下：" }, { "title": "两数之和II-输入有序数组", "url": "/posts/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8CII-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/", "categories": "数据结构与算法", "tags": "数组", "date": "2020-07-21 22:58:44 +0800", "snippet": "两数之和 II-输入有序数组给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。说明: 返回的下标值（index1 和 index2）不是从零开始的。 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素.示例 输入: numbers = [2, 7, 11, 15], target = 9输出: [1,2]解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。第一次思路：暴力求解暴力法，直接两层 for 循环，找到 target，但是最后发现时间复杂度太高，为 O(n^2)。无法满足题目的要求。class Solution{public: vector&amp;lt;int&amp;gt; twoSum(vector&amp;lt;int&amp;gt;&amp;amp; numbers, int target) { vector&amp;lt;int&amp;gt; result; if(numbers.size()&amp;lt;2) { return result; } for(int i=0;i&amp;lt;numbers.size();i++) { for(int j=i+1;;j&amp;lt;numbers.size();j++) { if(numbers[i]+numbers[j]==target) { result.push_back(++i); result.push_back(++j); return result; } } } }第二次思路：不计算重复值第二次改变思路，当两次求得值已经计算过，那就直接计算下一次。class Solution{public: vector&amp;lt;int&amp;gt; twoSum(vector&amp;lt;int&amp;gt;&amp;amp; numbers, int target) { vector&amp;lt;int&amp;gt; result; if(numbers.size()&amp;lt;2) { return result; } int used_1; int used_2; if(numbers.size()==2 &amp;amp;&amp;amp; (numbers[0]+numbers[1]==target)) { result.push_back(1); result.push_back(2); return result; } for(int i=0;i&amp;lt;numbers.size();i++) { int j=i+1; if(j&amp;lt;numbers.size() &amp;amp;&amp;amp; ((numbers[i] == used_1 &amp;amp;&amp;amp; numbers[j] == used_2) ||(numbers[j] == used_1 &amp;amp;&amp;amp; numbers[i] == used_2))) { continue; } for(;j&amp;lt;numbers.size();j++) { if(numbers[i]+numbers[j]==target) { result.push_back(++i); result.push_back(++j); return result; } used_1 = numbers[i]; used_2 = numbers[j]; } } return result; }};第三次思路：双指针策略第三次在看了答案之后裁只要要用双指针来做，可惜了，上次练习 leetcode 还是好久以前，都忘了。期间还把 result 和 numbers 弄混了，导致程序一开始就返回，得不到正确的结果。代码为：class Solution{public: vector&amp;lt;int&amp;gt; twoSum(vector&amp;lt;int&amp;gt;&amp;amp; numbers, int target) { vector&amp;lt;int&amp;gt; result; // 采用双指针left和right求解 if(numbers.size()&amp;lt;2) { return result; } int left = 0; int right = numbers.size()-1; while(left&amp;lt;right) { if(numbers[right]+numbers[left]==target) { result.push_back(left+1); result.push_back(right+1); break; } else if(numbers[right]+numbers[left]&amp;gt;target) { right--; } else { left++; } } return result; }};第四次思路：加入二分法思路在答案的基础上进行改进，上次只是在两数之和大于或小于的时候减一或加一，可采用二分法的思想，直接跳到中位值。但是中途遇到了问题，二分法适用于查找 1 个目标，这里有 2 个目标，所以要转换思路，求解 1 个目标才行。还要注意 while 循环条件要为 left&amp;lt;=right 才行，如果没有等于，就相当于 left=right 时，numbers[i]和 numbers[mid]没有进行相加，无法得到正确的答案class Solution{public: vector&amp;lt;int&amp;gt; twoSum(vector&amp;lt;int&amp;gt;&amp;amp; numbers, int target) { for (int i = 0; i &amp;lt; numbers.size(); i++) { int left = i + 1; int right = numbers.size() - 1; int mid; while (left &amp;lt;= right) { mid = (left + right) &amp;gt;&amp;gt; 1; if (numbers[mid] + numbers[i] == target) { return {i + 1, mid + 1}; } else if (numbers[mid] + numbers[i] &amp;gt; target) { right = mid - 1; } else { left = mid + 1; } } } return {}; }};" }, { "title": "《白日梦想家》观后感", "url": "/posts/%E7%99%BD%E6%97%A5%E6%A2%A6%E6%83%B3%E5%AE%B6-%E8%A7%82%E5%90%8E%E6%84%9F/", "categories": "观/读后感", "tags": "电影", "date": "2020-02-01 22:15:30 +0800", "snippet": "前言《白日梦想家》是由本·斯蒂勒(Ben Stiller)主演的一部奇幻剧情片，英文名为 The Secret Life of Walter Mitty。电影讲述了主角 Walter Mitty 是一个爱做白日梦的杂志社底片资产管理部经理。他经常会进入一种“出神”的状态，然后幻想自己做了很了不起的事情，但回到现实，自己并没有想象中那么富有传奇色彩。某天，当冒险摄影师发来当作最后一刊杂志的封面图片不见了时，Walter 不得不被迫改变固有的生活方式来亲自寻找，经历了一场不同寻常的冒险旅程。电影剧情在电影中，Walter Mitty 的生活看起来很平凡。他从事的工作是底片资产管理，这项工作看起来很枯燥，但他总是能够在工作中进入自己的白日梦世界。在这个世界里，他可以勇敢地面对自己的心上人，成为英雄，打败恶人。但当他回到现实中，他变得很安静，很害羞，不敢说出自己心中的想法。某天，当冒险摄影师肖恩发来的最后一刊杂志的封面图片不见了时，Walter 被迫改变自己的生活方式来亲自寻找这张照片，这也是他工作的责任所在。他开始了一场冒险旅程，从纽约到冰岛，再到阿富汗，最终到达了喜马拉雅山脉。在这个过程中，他遇到了很多有趣的人，也经历了很多惊险的事情。这个过程也让他重新审视了自己的人生，找到了自己的勇气和自信电影中杂志社的名字为 LIFE,意为生活,就像男主的生活一样，白日梦和现实互相交叉,即使是给喜欢的人在交友网站上发送一个笑脸都鼓起了莫大的勇气,在实际中也只能通过白日梦来想象自己博得了心上人的注意,打击了讽刺自己的上司,然而在现实却什么也不敢做,只是一个随时面临着被上司裁员风险的普通人,但是就是这样一个普通人,当得知了 25 号胶片找不到的时候,他急了,拼命地想找到这作为最后一期杂志封面的照片,何况这张照片还是冒险摄像师肖恩拍摄的,这也是他工作的责任所在,他为了询问肖恩,不惜离开多年工作和生活的地方,成为了一个勇敢的人,去放眼看世界,去做一些从来没有做过的事情,去看平时看不到的东西,这就是生活的意义.在冰岛公路用滑板迎风而行Walter 来到了冰岛,经历了火山爆发,在海洋中与鲨鱼搏斗,在喜马拉雅山上踢球.冰原,大海,鲨鱼,喜马拉雅山,walter 的白日梦远远没有现实生活壮丽多彩,最后他找到了哪张丢失的照片,原来这张照片就在一开始肖恩送给他的钱包中,当他拿起照片甩给上司时,感觉他整个人都得到了解放,更加没有想到的是,那张照片竟然就是他自己,标题写着”献给成就这本杂志的人”,这本杂志叫做生活,也代表本片是献给那些活在现实中的人.最后找到的照片.jpg电影的意义和我们所处的现实生活一样,做白日梦的人绝对不在少数,不过他们的白日梦不再会轻易的表达出来,往往是通过不切实际的想法,受到社会风气或者别人的话语所印象,产生不切实际的幻想,但重点不在这,重点在于行动,电影中男主角就是因为丢失了照片,为了找到照片这个目的,从而开始一系列的旅行,才能走出去看到世界的样子,如果人缺乏目标,就会不知所措,无所事事,就和我们现在的处境相似,因为疫情的影响被困在家里,缺乏目标,不知道该干什么,电视也看完了,电脑也玩够了,游戏也不想玩,每天不知道自己在做些什么,想做一些有意义的事又不知道该从何开始,这就是典型的缺乏目标了,但是每天清醒的时刻也就是每天晚上回想白天的时候,到第二天早上一切想法都烟消云散,根本不记得昨天晚上立下的 flag,也不记得当前的目标了,何不让我们成为电影中一样的人呢? 立下了目标,并且为目标倾尽全部精力!" }, { "title": "LeetCode455 分发饼干", "url": "/posts/LeetCode455-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/", "categories": "数据结构与算法", "tags": "贪心", "date": "2020-01-30 23:34:33 +0800", "snippet": "假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj 。如果 sj &amp;gt;= gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。注意：你可以假设胃口值为正。一个小朋友最多只能拥有一块饼干。示例 1: 输入: [1,2,3], [1,1] 输出: 1解释: 你有三个孩子和两块小饼干，3 个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是 1，你只能让胃口值是 1 的孩子满足。所以你应该输出 1。示例 2: 输入: [1,2], [1,2,3] 输出: 2解释: 你有两个孩子和三块小饼干，2 个孩子的胃口值分别是 1,2。你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出 2.思路，这个题目其实不难，但是我在第一遍做题目的时候竟然没有做出来，原因是因为程序逻辑没有理清楚，然后看了解答后才知道要使用贪心算法，而且程序也极为简单，根本不需要复杂的算法或者逻辑。代码如下：class Solution {public: int findContentChildren(vector&amp;lt;int&amp;gt;&amp;amp; g, vector&amp;lt;int&amp;gt;&amp;amp; s) { sort(g.begin(), g.end()); sort(s.begin(), s.end()); int count = 0; int glen = g.size(); int slen = s.size(); if (slen == 0) { return 0; } int gi = 0; int si = 0; //贪心算法，设置饼干和孩子索引，如果满足要求，饼干和孩子索引加1，如果不满足要求，饼干加1 //知道饼干或孩子个数上限 while (gi != glen &amp;amp;&amp;amp; si !=slen) { //饼干满足孩子 if (g[gi] &amp;lt;= s[si]) { gi++; si++; } else { si++; } } return gi; }};" }, { "title": "Leetcode215 数组中的第K个最大的元素", "url": "/posts/Leetcode215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A0/", "categories": "数据结构与算法", "tags": "数组", "date": "2020-01-30 23:32:02 +0800", "snippet": "Leetcode 215 数组中的第 K 个最大的元素直接排序后返回 k 即可。class Solution {public:int findKthLargest(vector&amp;lt;int&amp;gt;&amp;amp; nums, int k) { std::sort(nums.begin(),nums.end()); return nums[nums.size()-k]; }};" }, { "title": "LeetCode155 最小栈", "url": "/posts/LeetCode155-%E6%9C%80%E5%B0%8F%E6%A0%88/", "categories": "数据结构与算法", "tags": "栈", "date": "2020-01-30 23:31:19 +0800", "snippet": "LeetCode 155 最小栈设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。 push(x) – 将元素 x 推入栈中。pop() – 删除栈顶的元素。top() – 获取栈顶元素。getMin() – 检索栈中的最小元素。示例: MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); –&amp;gt; 返回 -3.minStack.pop();minStack.top(); –&amp;gt; 返回 0.minStack.getMin(); –&amp;gt; 返回 -2.想了一下，这个题目可以用两个栈来实现，一个栈储存正常的数据，另一个栈储存当前的最小值。需要返回最小值的时候直接返回最小栈的栈顶元素即可。弹出栈的时候也是同样的道理。最后代码如下：class MinStack {public: /** initialize your data structure here. */ MinStack() { } void push(int x) { s.push(x); if (min_s.empty()) { min_s.push(x); } else { if (x&amp;lt;min_s.top()) { min_s.push(x); } else { min_s.push(min_s.top()); } } } void pop() { s.pop(); min_s.pop(); } int top() { return s.top(); } int getMin() { return min_s.top(); }private: stack&amp;lt;int&amp;gt; s; stack&amp;lt;int&amp;gt; min_s;};看到网上别人的解法也很神奇，可以不用两个栈就可以实现该算法，可以用一个栈的两个数据位来保存数据，一个数据保存真正 push 进来的值，另一个数据保存当前的最小值，不过实际原理和用两个栈来实现么什么区别。" }, { "title": "LeetCode232 用栈实现队列", "url": "/posts/LeetCode232-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/", "categories": "数据结构与算法", "tags": "栈, 队列", "date": "2020-01-30 23:30:35 +0800", "snippet": "LeetCode232 用栈实现队列使用栈实现队列的下列操作： push(x) – 将一个元素放入队列的尾部。pop() – 从队列首部移除元素。peek() – 返回队列首部的元素。empty() – 返回队列是否为空。示例: MyQueue queue = new MyQueue();queue.push(1);queue.push(2);queue.peek(); // 返回 1queue.pop(); // 返回 1queue.empty(); // 返回 false思路和用队列实现栈一样，只需要注意 push 操作。最后代码如下，提交到 LeetCode 一次成功class MyQueue {public: /** Initialize your data structure here. */ MyQueue() { } /** Push element x to the back of queue. */ void push(int x) { stack&amp;lt;int&amp;gt; temp_s; while (!s.empty()) { int num = s.top(); s.pop(); temp_s.push(num); } s.push(x); while (!temp_s.empty()) { int num = temp_s.top(); temp_s.pop(); s.push(num); } } /** Removes the element from in front of queue and returns that element. */ int pop() { int num = s.top(); s.pop(); return num; } /** Get the front element. */ int peek() { return s.top(); } /** Returns whether the queue is empty. */ bool empty() { return s.empty(); }private: stack&amp;lt;int&amp;gt; s;};" }, { "title": "LeetCode225 用队列实现栈", "url": "/posts/LeetCode225-%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/", "categories": "数据结构与算法", "tags": "栈, 队列", "date": "2020-01-30 23:28:50 +0800", "snippet": "使用队列实现栈的下列操作： push(x) – 元素 x 入栈pop() – 移除栈顶元素top() – 获取栈顶元素empty() – 返回栈是否为空注意: 你只能使用队列的基本操作– 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。思考过程：用队列实现栈，首先队列是先进先出，而栈是先进后出，对于 pop 操作，即要弹出栈的尾部元素，top 操作即为要取栈尾，empty 检查是否为空，这几个都好写，主要的就是 push 操作，这个操作和队列很不一样。先实现其他操作吧， /** Removes the element on top of the stack and returns that element. */ int pop() { int num = q.front(); q.pop(); return num; } /** Get the top element. */ int top() { return q.front(); } /** Returns whether the stack is empty. */ bool empty() { return q.empty(); }private: queue&amp;lt;int&amp;gt; q;剩下的就是 push 操作了。用一个临时的队列来存放需要 push 的值，再将原队列中的值 push 进去。/** Push element x onto stack. */void push(int x) { queue&amp;lt;int&amp;gt; temp_q; while (!q.empty()) { int num = q.front(); q.pop(); temp_q.push(num); } q.push(x); while (!temp_q.empty()) { int num = temp_q.front(); temp_q.pop(); q.push(num); }}最后整体的代码为：class MyStack {public: /** Initialize your data structure here. */ MyStack() { } /** Push element x onto stack. */ void push(int x) { queue&amp;lt;int&amp;gt; temp_q; while (!q.empty()) { int num = q.front(); q.pop(); temp_q.push(num); } q.push(x); while (!temp_q.empty()) { int num = temp_q.front(); temp_q.pop(); q.push(num); } } /** Removes the element on top of the stack and returns that element. */ int pop() { int num = q.front(); q.pop(); return num; } /** Get the top element. */ int top() { return q.front(); } /** Returns whether the stack is empty. */ bool empty() { return q.empty(); }private: queue&amp;lt;int&amp;gt; q;};提交上去，显示结果无错误。" }, { "title": "LeetCode23 合并K个排序链表", "url": "/posts/LeetCode23-%E5%90%88%E5%B9%B6K%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/", "categories": "数据结构与算法", "tags": "链表", "date": "2020-01-30 23:28:09 +0800", "snippet": "合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。示例: 输入:[ 1-&amp;gt;4-&amp;gt;5, 1-&amp;gt;3-&amp;gt;4, 2-&amp;gt;6]输出: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5-&amp;gt;6有了上一个例子21的思路，这个题目就好做了，只需要设置一个头结点，然后三个互相比较不断的调整头结点的指向即可。后面又想了想，这样做有点不太好实现，可以把每个list的节点push到同一个vector中，比较提取出最小的值，然后一一保存，最后链接这些值。ListNode* mergeKLists(vector&amp;lt;ListNode*&amp;gt;&amp;amp; lists) { int len = lists.size(); if (len ==1) { return lists[0]; } if (len ==0) { return NULL; } vector&amp;lt;ListNode*&amp;gt; resultSet; for (int i=0;i&amp;lt;len;i++) { ListNode* head = lists[i]; while (head!=NULL) { resultSet.push_back(head); head = head-&amp;gt;next; } } std::sort(resultSet.begin(),resultSet.end(),cmp); resultSet.push_back(NULL); for (int j=0;j&amp;lt;resultSet.size()-1;j++) { resultSet[j]-&amp;gt;next = resultSet[j + 1]; } return resultSet[0];}bool cmp(const ListNode* a, const ListNode* b){ if (a-&amp;gt;val &amp;lt; b-&amp;gt;val) { return 1; } else { return 0; }}写出来了，但是无法通过测试，会报错。故直接看答案改写另一种方法。答案使用分治归并的思想解答。最终代码如下：ListNode* mergeKLists(vector&amp;lt;ListNode*&amp;gt;&amp;amp; lists) { int len = lists.size(); if (len == 0) { return NULL; } if (len == 1) { return lists[0]; } if (len == 2) { return mergeTwoLists(lists[0], lists[1]); } int mid = len / 2; vector&amp;lt;ListNode*&amp;gt; sub1_lists; vector&amp;lt;ListNode*&amp;gt; sub2_lists; int i; for (i=0;i&amp;lt;mid;i++) { sub1_lists.push_back(lists[i]); } for (int j = i;j&amp;lt;len;j++) { sub2_lists.push_back(lists[j]); } ListNode* l1 = mergeKLists(sub1_lists); ListNode* l2 = mergeKLists(sub2_lists); return mergeTwoLists(l1, l2);}ListNode* mergeTwoLists(ListNode* l1, ListNode* l2){ if (l1==NULL) { return l2; } if (l2 ==NULL) { return l1; } ListNode* p; ListNode* head = p; while (l1 !=NULL &amp;amp;&amp;amp; l2 != NULL) { if (l1-&amp;gt;val&amp;lt;l2-&amp;gt;val) { head-&amp;gt;next = l1; head = l1; l1 = l1-&amp;gt;next; } else { head-&amp;gt;next = l2; head = l2; l2 = l2-&amp;gt;next; } if (l1==NULL) { head-&amp;gt;next = l2; } if (l2 == NULL) { head-&amp;gt;next = l1; } } return p;}" }, { "title": "Leetcode32 合并两个有序链表", "url": "/posts/Leetcode32-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/", "categories": "数据结构与算法", "tags": "链表", "date": "2020-01-30 23:26:48 +0800", "snippet": "将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。示例： 输入：1-&amp;gt;2-&amp;gt;4, 1-&amp;gt;3-&amp;gt;4输出：1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4我的思路，这个题目要是不是可以用最简单的方式解决呢？假设两个链表的长度相等。那么遍历链表l1,然后依次让l2插入到l1后面。但是之后发现，题目中有可能是长度不一样的，那么我就更改为如果l2比l1长，那么就从l1插入到l2，反之亦然。但是例子中又有l1或l2为空的情况，我又设置为l1为空就返回l2,反之亦然。但是我在这里卡住了。 输入[5][1,2,4]输出[1,5,2,4]预期结果[1,2,4,5]这里明显l2比l1长，那么应该讲l1插入到l2中，最终结果应该是1,5,2,4，后面认真审题后发现，题目为讲两个有序链表合并为一个新的有序链表并返回。也就是说， 输入的两个链表都是有序的，而且输入的链表可能为0； 输出的链表也是有序的，而且是通过输入链表组合而得到的。重新整理一下思路，首先对边界进行限制，即考虑l1和l2为null的情况，然后将l1中的元素插入到l2中去。写了一段时间，不会，直接看答案吧，有2中解法，我使用了迭代的方法，成功了，唯一需要注意的是最后一个元素需要单独添加。ListNode* mergeTwoLists(ListNode* l1, ListNode* l2){ if (l1==NULL) { return l2; } if (l2 == NULL) { return l1; } ListNode* p1 = l1; ListNode* p2 = l2; ListNode* head = new ListNode(0); ListNode* p = head; //迭代方法 while ( p2!=NULL &amp;amp;&amp;amp; p1!=NULL) { if (p1-&amp;gt;val &amp;lt; p2-&amp;gt;val) { p-&amp;gt;next = p1; p1 = p1-&amp;gt;next; } else { p-&amp;gt;next = p2; p2 = p2-&amp;gt;next; } p = p-&amp;gt;next; } if (p1 == NULL) { p-&amp;gt;next = p2; } if (p2 == NULL) { p-&amp;gt;next = p1; } return head-&amp;gt;next;}" }, { "title": "LeetCode138 链表的深度拷贝", "url": "/posts/LeetCode138-%E9%93%BE%E8%A1%A8%E7%9A%84%E6%B7%B1%E5%BA%A6%E6%8B%B7%E8%B4%9D/", "categories": "数据结构与算法", "tags": "链表", "date": "2020-01-30 23:22:27 +0800", "snippet": "题目给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。要求返回这个链表的深拷贝。示例：输入：{“$id”:”1”,”next”:{“$id”:”2”,”next”:null,”random”:{“$ref”:”2”},”val”:2},”random”:{“$ref”:”2”},”val”:1}解释：节点 1 的值是 1，它的下一个指针和随机指针都指向节点 2 。节点 2 的值是 2，它的下一个指针指向 null，随机指针指向它自己。这个题目有一定难度的，难度在于随机指针。这个指针域该怎么复制是一个很重要的问题。深度拷贝：原链表和新链表不互相影响，可以随意更改。这个题目可以用 map 来计算，主要是存储随机指针之间的逻辑关系，map 中存储的是地址和节点 ID 的映射。难点有两点： 1.随机指针指向了哪一个节点？ 2.这个节点的地址是多少？而用 map 就是为了解决这两点的。我自己的思路：首先存储随机指针指向的 ID，然后新建新的指针，顺便保存值和指针以及随机指针三个参数，返回新的指针。写代码发现行不通，不知道该怎么写，存储随机指针以及保存其他的指针都好写，但是怎么新建新指针和将新指针的 next 域、random 域和原来的联系起来，这里不知道怎么写。这里我的思路是有问题的，原因是我没有想清楚该做什么。我的思路是保存随机指针指向的 ID，这一步保存 ID 是对的，但是随机指针不对，这里保存的应该是新链表中的指针，而不是旧链表，同理，新建新的指针时，值可以保存，但是 next 指针和随机指针不能一次性保存的。正确的方法，应该是，根据原链表的长度建立新链表，仅仅将值域的值赋值，next 域和 random 域暂时不用管，并且将新节点存放到 vector 中，然后保存旧节点的地址对应的 id。然后再次遍历旧节点，连接新节点的 next 域，然后由于 map 中保存的是旧节点的地址，所以对旧节点的 random 域取地址，该地址一定在 map 中，且对应的 key 值即为指向的 id，结合该 id 在 vector 中索引，即可得到新节点中的 random 指针的地址。最终代码如下：Node* copyRandomList(Node* head){ std::map&amp;lt;Node*, int &amp;gt; node_map; std::vector&amp;lt;Node*&amp;gt; node_vec; Node* ptr = head; int i = 0; while (ptr) { node_vec.push_back(new Node(ptr-&amp;gt;val)); //记录ptr 和ID的映射 node_map[ptr] = i++; ptr = ptr-&amp;gt;next; } node_vec.push_back(0); ptr = head; i = 0; while (ptr) { node_vec[i]-&amp;gt;next = node_vec[i + 1]; if (ptr-&amp;gt;random!=NULL) { int id = node_map[ptr-&amp;gt;random];//get ID node_vec[i]-&amp;gt;random = node_vec[id]; } ptr = ptr-&amp;gt;next; i++; } return node_vec[0];}" }, { "title": "LeetCode86 分割链表", "url": "/posts/LeetCode86-%E5%88%86%E5%89%B2%E9%93%BE%E8%A1%A8/", "categories": "数据结构与算法", "tags": "链表", "date": "2020-01-30 23:20:47 +0800", "snippet": "题目给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。你应当保留两个分区中每个节点的初始相对位置。输入: head = 1-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;5-&amp;gt;2, x = 3输出: 1-&amp;gt;2-&amp;gt;2-&amp;gt;4-&amp;gt;3-&amp;gt;5思路这个题目，先开始是我的思路错误，虽然我知道这个题目需要设置临时头结点，但是由于审题不清，我最先开始是想设置一个临时的结点 tempnode，然后小于 x 就插入 tempnode 之前，大于或等于 x 就插入 tempnode 之后，但是当我看完相关的视频之后，发现题目的要求并不是这样的，因为题目是要求保持相对位置，而如果像我那样插入就会出现这样的情况：1-&amp;gt;2-&amp;gt;2-&amp;gt;tempnode-&amp;gt;5-&amp;gt;3-&amp;gt;4这样的结果就和题目要求的相反，看过正确答案后，不得不承认这个题目非常简单，只需要设置两个头结点，temp_less 和 temp_more，将小于 x 的值插入 temp_less 后面，将大于或者等于 x 的值插入到 temp_more 后面，然后将 temp_less 和 temp_more 链接起来，并将 temp_more 的 next 指针赋值为 NULL，最后返回 temp_less-&amp;gt;next 即可。中间出现时间超过限制的错误，最后发现不断有输出数据跳出来，检查发现，temp_more 的指针没有赋值为 NULL，故不断循环下去。另外注意的是链接两个链表时要连接头结点！！！而 temp_less 和 temp_more 不在是头结点了。最终代码如下：//技巧在于巧用临时头结点 ListNode less_head(0); ListNode more_head(0); ListNode* tempnode_less = &amp;amp;less_head; ListNode* tempnode_more = &amp;amp;more_head; ListNode* result = head; //if head is not NULL while (head) { //save head &#39;s next ListNode* next = head-&amp;gt;next; if (head-&amp;gt;val &amp;lt;x) { //create less x list node tempnode_less-&amp;gt;next = head; tempnode_less = head; } else { //create more x list node tempnode_more-&amp;gt;next = head; tempnode_more = head; } //begin next node head = next; } //connect list node, care of &quot;more_head.next&quot; tempnode_less-&amp;gt;next = more_head.next; tempnode_more-&amp;gt;next = NULL; return less_head.next;最终用时：超过一小时" }, { "title": "机器学习之线性回归笔记", "url": "/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E7%AC%94%E8%AE%B0/", "categories": "机器学习", "tags": "线性回归", "date": "2020-01-30 23:17:53 +0800", "snippet": "环境准备平台：windows10 64 位IDE：PycharmPython 版本：Python3.5github 代码：源代码回归的理解回归是由高尔顿最先在生物遗传上提出的，在线性回归中，与其说其为回归，不如说线性拟合更合适，而为了纪念高尔顿还是保留了回归这一名词而对数几率回归（Logistic regression）解决的却是一个分类问题，其实就是 2 分类，如果需要解决多分类那么就做多次 2 分类或直接用Softmax 回归。线性回归线性回归试图建立的一个线性模型以尽可能准确的预测输出标记。考虑最简单的模型，给定若干对$(x,y)$的数据，将其在坐标轴上表示如下：![散点图](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctYmxvZy5jc2RuLm5ldC8yMDE4MDMxNDIyMjYxOTQ1Mj93YXRlcm1hcmsvMi90ZXh0L0x5OWliRzluTG1OelpHNHVibVYwTDNGeE9UQTBNekExTVRVNS9mb250LzVhNkw1TDJUL2ZvbnRzaXplLzQwMC9maWxsL0kwSkJRa0ZDTUE9PS9kaXNzb2x2ZS83MA?x-oss-process=image/format,png)线性回归就是要寻找一条直线来使得这些所有的点都尽量符合直线上的点，其中尽量符合指的就是使损失最小，在这里以点到直线的距离的平方来作为‘损失’，使用线性回归可以来预测数据，这在机器学习里面是一个非常重要的概念——预测，不管是什么模型，最后做出来都是需要用来预测数据，来判断这个模型到底实不实用，线性回归就是这些模型中最简单的一种模型。![线性回归图](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctYmxvZy5jc2RuLm5ldC8yMDE4MDMxNDIyMjY1MDM4Mj93YXRlcm1hcmsvMi90ZXh0L0x5OWliRzluTG1OelpHNHVibVYwTDNGeE9UQTBNekExTVRVNS9mb250LzVhNkw1TDJUL2ZvbnRzaXplLzQwMC9maWxsL0kwSkJRa0ZDTUE9PS9kaXNzb2x2ZS83MA?x-oss-process=image/format,png)## 使用最大似然解释最小二乘### 基本形式首先对于线性回归，所求得就是一条直线，设其方程为：$$y^{(i)}=\\theta^Tx^{(i)}+\\varepsilon^{(i)}$$其中$\\theta$和$\\varepsilon$为这条直线的斜率和截距，$x,y$分别为图上的一系列散点，用极大似然法估计时，我们认为$\\varepsilon$符合正太分布，且期望为 0，那么根据大学的知识可以得到$\\varepsilon$的概率为：$$p(\\varepsilon^{(i)})=\\frac{1}{s\\sqrt{2\\pi\\sigma}}exp(-\\frac{(\\varepsilon^{(i)})^2}{2\\sigma^2})$$把直线方程移项带入上式得到在$\\theta$参数下，已知$x$的情况下$y$的概率密度函数为：$$p(y^{(i)}|x^{(i)};\\theta)=\\frac{1}{\\sqrt{2\\pi\\sigma}}exp(-\\frac{(y^{(i)}-\\theta^Tx^{(i)})^2}{2\\sigma^2})$$这里的概率密度函数为条件概率密度函数，直接求解是无法解出来的，假设样本之间是独立的，那么就得到：\\begin{aligned}L(\\theta)&amp;amp;=\\coprod*{i=1}^m p(y^{(i)}|x^{(i)};\\theta)\\\\&amp;amp;=\\coprod*{i=1}^m\\frac{1}{\\sqrt{2\\pi\\sigma}}exp(-\\frac{(y^{(i)}-\\theta^Tx^{(i)})^2}{2\\sigma^2})\\end{aligned}### 高斯的对数似然与最小二乘这里用的是对数似然，即需要对$L(\\theta)$取对数，则可以化简得到如下方程：\\begin{aligned}\\ell(\\theta)&amp;amp;=\\log{L(\\theta)}\\\\&amp;amp;=\\log{\\coprod*{i=1}^m\\frac{1}{\\sqrt{2\\pi\\sigma}}exp(-\\frac{(y^{(i)}-\\theta^Tx^{(i)})^2}{2\\sigma^2})}\\\\&amp;amp;=\\sum*{i=1}^m \\log{\\frac{1}{\\sqrt{2\\pi\\sigma}}exp(-\\frac{(y^{(i)}-\\theta^Tx^{(i)})^2}{2\\sigma^2})}\\\\&amp;amp;=m\\log{\\frac{1}{\\sqrt{2\\pi\\sigma}}}-\\frac{1}{\\sigma^2}\\cdot\\frac{1}{2}\\sum*{i=1}^m(y^{(i)}-theta^Tx^{(i)})\\end{aligned}现在，需要求$L(\\theta)$为最大值时$\\theta$的值，前面一项为常数，可以省略掉，只保留后方一项得到函数：$$J(\\theta)=\\frac{1}{2}\\sum*{i=1}^m(y^{(i)}-\\theta^Tx^{(i)})$$即求$J(\\theta)$的最小值，括号里的一项就是预测值和实际值之间的差，这个就成为目标函数或成为损失函数，这其实就是最小二乘估计，整个推导过程其实就是利用高斯分布推导最小二乘。### 向量表示下的求解设有$M$个$N$维样本组成矩阵$X$，即$X$的行对应每个样本，$X$的列对应样本的维度，**目标函数**就可以表示为：$$J(\\theta)=\\frac{1}{2}\\sum_{i=1}^m (h_\\theta(x^{(i)})-y^{(i)})^2=\\frac{1}{2}(X\\theta-y)^T(X\\theta-y)$$即现在要求出$J(\\theta)$最小值时$\\theta$的值，对目标函数求导，令其等于$0$，求出$\\theta$的值。\\begin{aligned}\\nabla*\\theta J(\\theta) &amp;amp;= \\frac{1}{2}\\sum*{i=1}^m(h*\\theta x^{(i)}-y^{(i)})^2\\\\&amp;amp;=\\nabla*\\theta \\left\\{ \\frac{1}{2} (\\theta^TX^TX\\theta-]theta^TX^Ty-y^TX\\theta+h^Ty)\\right\\}\\\\&amp;amp;=\\frac{1}{2}(2X^TX\\theta-X^Ty-(y^TX)^T)\\\\&amp;amp;=X^TX\\theta-x^Ty\\end{aligned}得到最后的结果如下：$$\\theta=(X^TX)^{-1}X^Ty$$### L2 正则化($\\ell2-norm$)而在现实中当特征比样本点更多时，矩阵$X$不是满秩矩阵， $X^TX$不一定可逆，通常引入**正则化(egularization)**项，其实质是为了**防止过拟合**,$$ \\frac{1}{2}\\sum*{i=1}^m(h*\\theta x^{(i)}-y^{(i)})^2+\\lambda\\sum\\_{j=1}^n\\theta_j ^2$$称为**$L2$正则($\\ell2-norm$)**，那么加了$L2$正则的最小二乘称为**岭回归**，求解可得$\\theta$为：$$\\theta=(X^TX+\\lambda I)^{-1}X^Ty$$### L1 正则化($\\ell1-norm$)既然有 L2 正则化，那么也必然有**L1 正则化($\\ell1-norm$)**，将目标函数正则项中$\\theta$的平方替换为$\\theta$的绝对值，那么就叫 L1 正则，即**LASSO**。$$ \\frac{1}{2}\\sum*{i=1}^m(h*\\theta x^{(i)}-y^{(i)})^2+\\lambda\\sum\\_{j=1}^n|\\theta_j| $$### lastic Net结合 l1 和 l2 正则，即为 Elastic Net:$$ \\frac{1}{2}\\sum*{i=1}^m(h*\\theta x^{(i)}-y^{(i)})^2+\\lambda(\\rho\\cdot\\sum*{j=1}^n|\\theta_j| +(1-\\rho)\\cdot\\sum*{j=1}^n\\theta_j ^2)$$### L1 和 L2 正则的区别使用绝对值取代平方和，在$\\lambda$最够大时，高阶的情况下高阶项的系数会缩减到 0## 梯度下降法求出目标函数了，就要根据目标函数来求的这条直线，这里常用的一种方法就是梯度下降法，梯度下降法的公式如下：$$\\theta=\\theta-\\alpha\\cdot\\frac{\\partial J(\\theta)}{\\partial\\theta}$$其中$\\alpha$表示学习率，$\\theta$为参数，具体做法就是初始化$\\theta$，然后沿着负梯度方向迭代，不断更新$\\theta$使就$J(\\theta)$最小。## 程序分析```pythonimport numpy as npimport matplotlib.pyplot as pltnp.random.seed(0)x = np.linspace(0, 6, 11) + np.random.randn(11)x = np.sort(x)y = x ** 2 + 2 + np.random.randn(11)```首先生成随机点 x，y，随机生成 11 个点，这 11 个点是根据 y=x2+2 这条曲线上生成的。```pythondef optimizer(): w = 0 b = 0 for i in range(1000): w, b = compute_gradient(w, b, 0.02) # if i % 50 == 0: # plt.plot(x, x * w + b, &#39;b-&#39;) # plt.pause(0.5) y_pre = x * w + b print(w, b) return y_pre```这个函数是执行梯度下降法 1000 次，以此来找到最优的 w，b，每执行一次，都将新的 w，b 带入梯度中来求，最后求得最终的 w，b，然后可以得到最终拟合的直线，即 y_pre.```pyhondef compute_gradient(m_current, b_current, learning_rate): N = len(x) # 数据的长度 m_gradient = 0.0 b_gradient = 0.0 for i in range(N): m_gradient += -(2 / N) * x[i] * (y[i] - (m_current * x[i] + b_current)) b_gradient += -(2 / N) * (y[i] - (m_current * x[i] + b_current)) new_m = m_current - (learning_rate * m_gradient) new_b = b_current - (learning_rate * b_gradient) return new_m, new_b```在 compute_gradient 函数中，主要是返回每次计算的$w，b$以及$\\frac{\\partial J(\\theta)}{\\partial\\theta}$，上面函数中 for 循环就是所求的偏导数，返回值是计算一次梯度下降时的$w，b$。```pythonplt.plot(x, y, &#39;ro&#39;)plt.plot(x, optimizer(), &#39;b-&#39;)#optimizer()plt.show()```在多次计算后，再将散点图最终求得的直线图画出来即可。## 分析 sklearn 线性回归的官方例程官方网站为：[Linear Regression Example](http://scikit-learn.org/stable/auto_examples/linear_model/plot_ols.html#sphx-glr-auto-examples-linear-model-plot-ols-py)### 官方例程分析```pythonimport matplotlib.pyplot as pltimport numpy as npfrom sklearn import datasets, linear_modelfrom sklearn.metrics import mean_squared_error, r2_score```导入库```diabetes = datasets.load_diabetes() # 导出数据集```导出数据集，其中 diabetes 是`sklearn.datasets.base.Bunch`类型，该类型和 Python 内置的字典类型相似```diabetes_X = diabetes.data[:, np.newaxis, 2] # 分割数据集```这个用法为 sklearn 中的用法，`datasets.data`为`dataset`对象中的`data`属性，而`data`属性对应的数据为一个二维数组，故`[:, np.newaxis,2]`为取 data 中的所有行，增加一个维度，第三列,故`diabetes_X`为一个二维数组,如下：```{&#39;data&#39;: array([[ 0.03807591, 0.05068012, 0.06169621, ..., -0.00259226, 0.01990842, -0.01764613], [-0.00188202, -0.04464164, -0.05147406, ..., -0.03949338, -0.06832974, -0.09220405], [ 0.08529891, 0.05068012, 0.04445121, ..., -0.00259226, 0.00286377, -0.02593034], ..., [ 0.04170844, 0.05068012, -0.01590626, ..., -0.01107952, -0.04687948, 0.01549073], [-0.04547248, -0.04464164, 0.03906215, ..., 0.02655962, 0.04452837, -0.02593034], [-0.04547248, -0.04464164, -0.0730303 , ..., -0.03949338, -0.00421986, 0.00306441]]),```上面得到的 diabetes_X 的 shape 为(442, 1)，再将其分为训练集和测试集```diabetes_X_train = diabetes_X[:-20]diabetes_X_test = diabetes_X[-20:]```该句中前 0 个到倒数第 20 个分为训练集，倒数 20 个数据为测试集。```diabetes_y_train = diabetes.target[:-20]diabetes_y_test = diabetes.target[-20:]```同理，将 diabetes 中的 target 属性也这样划分。```regr = linear_model.LinearRegression()regr.fit(diabetes_X_train, diabetes_y_train)diabetes_y_pred = regr.predict(diabetes_X_test)```然后创建一个线性模型的对象，并用训练集来 fit，最后得到预测的数据```# The coefficientsprint(&#39;Coefficients: \\n&#39;, regr.coef_)# The mean squared errorprint(&quot;Mean squared error: %.2f&quot; % mean_squared_error(diabetes_y_test, diabetes_y_pred))# Explained variance score: 1 is perfect predictionprint(&#39;Variance score: %.2f&#39; % r2_score(diabetes_y_test, diabetes_y_pred))```打印出相关系数和均方误差以及差异分数这里相关系数为$R$，回归系数为$R^2$,而回归系数$$R^2=\\frac{SSReg}{SST}=1-\\frac{SSE}{SST}$$其中$SSReg$为回归平方和（sum of squares for regression），也叫做模型平方和，，SSE 为残差平方（sum of squares for error），SST 为总平方和（SSReg+SSE），其中各公式如下：$$SST=\\sum_{i=1}^n(y_i-\\bar{y})^2$$$$SSReg=\\sum_{i}(\\hat{y_i}-\\bar{y})^2$$$$SSE=\\sum_{i}(y_i-\\hat{y})^2$$故在本次实验中相关系数$R$即为：$$R=\\frac{\\sum_{i=1}^n(x_i-\\bar{x})(y_i-\\bar{y})}{\\sqrt{\\sum_{i=1}^n(x_i-\\bar{x})^2\\sum_{i=1}^n(y_i-\\bar{y})^2}}$$$\\hat{y_i}$表示的为回归直线中$y$的值，$\\bar{y}$表示$y$的平均值.最后结果如下：![官方例程结果](https://img-blog.csdn.net/20180328112825821?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxOTA0MzA1MTU5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)## 7.2 使用sklearn方法训练自己生成的数据代码如下：```pythonimport matplotlib.pyplot as pltimport numpy as npfrom sklearn import datasets, linear_modelfrom sklearn.metrics import mean_squared_error, r2_scorenp.random.seed(0)x = np.linspace(0, 6, 11) + np.random.randn(11)x = np.sort(x)y = x \\*\\* 2 + 2 + np.random.randn(11)x=x[:,np.newaxis]print(x)regr = linear_model.LinearRegression()regr.fit(x,y)y_pre = regr.predict(x)plt.scatter(x,y)plt.plot(x,y_pre)plt.show()```预测结果：![sklaern预测生成数据结果](https://img-blog.csdn.net/20180328113152895?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxOTA0MzA1MTU5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)可以看到，使用sklearn的预测结果和使用梯度下降法的线性回归结果是一模一样的。# 8 参考书目- 机器学习实战- 机器学习 周志华- [线性回归理解（附纯python实现）](http://blog.csdn.net/sxf1061926959/article/details/66976356?locationNum=9&amp;amp;fps=1)- [sklaern官网例程](http://scikit-learn.org/stable/auto_examples/linear_model/plot_ols.html#sphx-glr-auto-examples-linear-model-plot-ols-py)```" }, { "title": "机器学习之决策树笔记", "url": "/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%86%B3%E7%AD%96%E6%A0%91%E7%AC%94%E8%AE%B0/", "categories": "机器学习", "tags": "决策树", "date": "2020-01-30 22:50:13 +0800", "snippet": "环境准备平台：windows10 64 位IDE：PycharmPython 版本：Python 3.5github 代码：源代码 my_DecisionTree.py决策树决策树(decision tree)是一种常见的机器学习方法，其实在生活中我们已经用到了决策树相关的知识，比如说，女生相亲时的想法就是决策树的一种体现：那么对于一般女生来说，首选的就是看对方年龄，根据年龄是否超过 30 来决定见不见南方，如果超过，不见，如果没有超过就继续判断，依次类推，这就是一个决策树。那么对于上面的决策树来说，要解决的问题就是对当前男生的数据构建一颗决策树，用来对未来男生进行分类，即当要进行下一次相亲时，根据决策树来判断是否见面。一般的，一颗决策树包含一个根节点、若干个内部节点和若干个叶节点，叶节点对应决策及结果，其他节点对应于一个属性的测试。可以很轻松的理解到，上图中年龄为根节点，长相、收入、公务员为内部节点，见或不见为叶节点。基本算法数据划分要想建立一个决策树，首先需要建立一个根节点，对于以上的数据集来说就是先根据那个类别来划分，即‘outlook、temperature、humidity、windy’中的哪个类别作为根节点，这就需要一个量来作为度量，那就是信息增益，以信息增益来作为划分依据的成为ID3（Iterative Dichotomiser 迭代二分器）算法，还有以增益率（gain ratio）来划分的称为C4.5 算法，以基尼系数（Gini index）划分的成为CART 决策树。信息增益信息熵信息熵（information entropy）是用来度量信息源的不确定度。它的公式如下：\\[Ent(D)=-\\sum_{k=1}^{|y|}p_k\\log_2p_k \\tag{1}\\]其中$p_k$为数据集$D$中的$k$类样本所占的比例，$Ent(D)$越小，则$D$的纯度越高。对于 weka 数据集来说，该数据集共有 14 个样本，用来预测某一天是否合适外出游玩，那么显然这里就得$k=1,2$，即外出或不外出两种情况，外出所占比例为$\\frac{9}{14}$，而不外出所占比例为$\\frac{5}{14}$，根据以上公式根节点的信息增益可以计算出来为：\\(Ent(D)=-(\\frac{9}{14}\\log_2\\frac{9}{14}+\\frac{5}{14}\\log_2\\frac{5}{14}=0.94)\\)即为该数据集的信息熵。条件熵条件熵的公式如下：\\(Ent(D)=-\\sum_{v=1}^V\\frac{|D^v|}{|D|}Ent(D^v)\\tag{2}\\)以‘outlook’为例来计算在 outlook 条件下的信息熵，那么就要计算当前属性集合中的每个属性的信息增益，即‘sunny’‘overcast’‘rainy’这三个属性的每一个属性的信息增益，先来计算 sunny 属性的信息增益，将天气为sunny的保留，得到如下所示数据集： outlook temperature humidity windy play sunny hot high FALSE no sunny hot high TRUE no sunny mild high FALSE no sunny cool normal FALSE yes sunny mild normal TRUE yes 这里在sunny的情况下，外出所占比例为$\\frac{2}{5}$，不外出比例为$\\frac{3}{5}$，故可以计算出此时的信息熵$Ent(D^1)$，同样的情况下可以计算出overcast，rainy的信息熵$Ent(D^2)$，$Ent(D^3)$，然后sunny占outlook比例为$\\frac{5}{14}$，overcast和raniy占比为$\\frac{4}{14}$,$\\frac{5}{14}$,那么此时的信息增益即为：$Gain(D,outlook)=Ent(D)-(\\frac{5}{14}Ent(D^1)+\\frac{4}{14}Ent(D^2)+\\frac{5}{14}Ent(D^3)$这就是outlook属性的信息增益，同样可以计算出其他属性的信息增益，将其比较大小，找出最大值作为第一次分类的特征，即作为根节点。然后依次迭代循环，计算出整个决策树。Python 代码dataSet = [[&#39;sunny&#39;, &#39;hot&#39;, &#39;high&#39;, &#39;FALSE&#39;, &#39;no&#39;], [&#39;sunny&#39;, &#39;hot&#39;, &#39;high&#39;, &#39;TRUE&#39;, &#39;no&#39;], [&#39;overcast&#39;, &#39;hot&#39;, &#39;high&#39;, &#39;FALSE&#39;, &#39;yes&#39;], [&#39;rainy&#39;, &#39;mild&#39;, &#39;high&#39;, &#39;FALSE&#39;, &#39;yes&#39;], [&#39;rainy&#39;, &#39;cool&#39;, &#39;normal&#39;, &#39;FALSE&#39;, &#39;yes&#39;], [&#39;rainy&#39;, &#39;cool&#39;, &#39;normal&#39;, &#39;TRUE&#39;, &#39;no&#39;], [&#39;overcast&#39;, &#39;cool&#39;, &#39;normal&#39;, &#39;TRUE&#39;, &#39;yes&#39;], [&#39;sunny&#39;, &#39;mild&#39;, &#39;high&#39;, &#39;FALSE&#39;, &#39;no&#39;], [&#39;sunny&#39;, &#39;cool&#39;, &#39;normal&#39;, &#39;FALSE&#39;, &#39;yes&#39;], [&#39;rainy&#39;, &#39;mild&#39;, &#39;normal&#39;, &#39;FALSE&#39;, &#39;yes&#39;], [&#39;sunny&#39;, &#39;mild&#39;, &#39;normal&#39;, &#39;TRUE&#39;, &#39;yes&#39;], [&#39;overcast&#39;, &#39;mild&#39;, &#39;high&#39;, &#39;TRUE&#39;, &#39;yes&#39;], [&#39;overcast&#39;, &#39;hot&#39;, &#39;normal&#39;, &#39;FALSE&#39;, &#39;yes&#39;], [&#39;rainy&#39;, &#39;mild&#39;, &#39;high&#39;, &#39;TRUE&#39;, &#39;no&#39;]]labels = [&#39;outlook&#39;,&#39;temperature&#39;,&#39;humidity&#39;,&#39;windy&#39;,&#39;play&#39;]首先创建数据集，以列表的方式存储。def calcentropy(data): numentropy = len(data) labelCounts = {} for featVec in data: # 数据集的每一行 currentlabel = featVec[-1] # 每一行的最后一个类别 if currentlabel not in labelCounts.keys(): # 如果当前标签不在字典的关键字中 labelCounts[currentlabel] = 0 # 让当前标签为0，实际上是增加字典的关键字 labelCounts[currentlabel] += 1 # 如果在字典里，就增加1，实际上是统计每个标签出现的次数 shannonEnt = 0 # 香农熵，即最后的返回结果 for key in labelCounts: # 遍历labelCount中的每一个关键词 prob = labelCounts[key] / numentropy # 用关键词的个数除以总个数得到概率 shannonEnt -= prob * np.log2(prob) # 求信息熵，即香农熵return shannonEnt然后创建一个函数用来计算信息熵，这个函数有个特点就是用 for 循环和字典来记录一列数据中每个属性出现的次数，然后通过出现的次数除以总次数来计算概率，最后求得信息熵。def splitData(data, axis, value): # 划分数据集 retData = [] for featVec in data: # 用featVec表示每一个样本 if featVec[axis] == value: # 如果value的值等于里面样本的特征 reduceFeat = featVec[:axis] # 用reduceFeat补齐这个特征之前的所有特征 reduceFeat.extend(featVec[axis + 1:]) # 补齐这个特征之后的所有特征 retData.append(reduceFeat) # 用retData来表示去掉这个特征的最终特征return retData该函数为划分数据集函数，这里面用 reduceFeat 来存储去掉某个特征之后的数据集，然后返回该数据集用以迭代循环。def chooseBestFeatSplit(data): numFeats = len(data[0]) - 1 # 特征的数目，减去最后一个特征 bestGain = 0 for i in range(numFeats): # i：0-3，在本例中只有4个特征 featlist = [example[i] for example in data] # 列表解析取出data中的一列数据 uniqueVals = set(featlist) # 转变为集合 newEntropy = 0 for value in uniqueVals: # 遍历每个特征内所有集合的元素，对于i=0是，uniqueVals={summy,rainy,overcast} subData = splitData(data, i, value) # 对第一个特征中rainy划分数据集 prob = len(subData) / float(len(data)) newEntropy += prob * calcentropy(subData) # 求出条件熵 infoGain = baseGain - newEntropy # 计算信息增益 if infoGain &amp;gt; bestGain: # 取出最大的信息增益 bestGain = infoGain bestfeat = ireturn bestfeat # 返回当信息增益最大是的特征类别该函数是选择最佳的特征来分类，是整个步骤中最重要的一步，这里它用了一个列表解析取出数据集中某一列数据，然后转变为集合，通过比较每个类别的信息增益来返回最佳的特征def creatTree(data, labels): classList = [example[-1] for example in data] # 遍历数据集最后一列 if classList.count(classList[0]) == len(classList): # 类别中的概率是否确定，即概率为1时，提前到达叶节点 return classList[0] # 返回该类别 if len(data[0]) == 1: # 是否只剩下一个类别，到达最终的叶节点 return majorityCnt(classList) bestFeature = chooseBestFeatSplit(data) # 选择最好的特征 bestFeatureLabel = labels[bestFeature] # 最好的特征表现 myTree = {bestFeatureLabel:{}} # 创建树 del(labels[bestFeature]) # 删除已经计算过的特征 featValues = [example[bestFeature] for example in data] # 遍历根据最佳特征分割完成后的类别中的属性 uniqueVals = set(featValues) for value in uniqueVals: sublabels = labels[:] myTree[bestFeatureLabel][value] = creatTree(splitData(data,bestFeature,value),sublabels)return myTree该函数即为上图中决策树学习的基本算法，可以看到，它以 2 个条件做为迭代终止的条件，第一个是样本在类别中取值相同，这就说明已经到达了叶子节点，做出了最终决策，该阶段任务完成。第二个是只剩下一个类别时，迭代终止，到达最终的叶子节点。以上程序为树的核心程序，剩下的用 matplot 绘图工具将生成的树绘出即可，程序如下if __name__ == &#39;__main__&#39;: baseGain = calcentropy(dataSet) myTree = creatTree(dataSet,labels) print(myTree)最后运行结果出的决策树如下：参考书目 机器学习 周志华 机器学习实战 Python3《机器学习实战》学习笔记（二）：决策树基础篇之让我们从相亲说起" }, { "title": "turtlebot3（一）之Ubuntu16.04上realsenceR200的使用", "url": "/posts/turtlebot3-%E4%B8%80-%E4%B9%8BUbuntu16-04%E4%B8%8ArealsenceR200%E7%9A%84%E4%BD%BF%E7%94%A8/", "categories": "机器人", "tags": "turtlebot", "date": "2020-01-30 22:48:08 +0800", "snippet": "前言最近实验室买了 turtlebot3，捣鼓了 1 个月，先是跑通了激光雷达 demo，现在又跑 realsenseR200 的 demo，现在将 realsense demo 的跑通过程记录下来。设备：turtlebot3平台：Ubuntu16.04.3内核：4.4.14（17.12 月之前最新的内核）安装过程主要参考了intel 的 github 项目，在该网址上可以看到说明这个包适用于深度摄像机 D400 系列和 SR300，而实验室的摄像头信号是 R200，需要到另一个适用 R200 的网址安装,如下所示:在这个网址安装时，由于当时使用git clone下载，后来发现下载的文件就是并非使用于 R200，所以建议直接下载 zip 文件，现在之后根据页面的安装手册，可以比较轻松的完成。##3rd-party首先，需要安装 3rd-party 依赖 1.保证 apt-get 的更新sudo apt-get update &amp;amp;&amp;amp; sudo apt-get upgrade2.安装libusb-1.0和pkg-configsudo apt-get install libusb-1.0-0-dev pkg-config3.安装glfw3，Ubuntu14.04 需要用脚本安装（详见英文文档），Ubuntu16.04 可以直接用 apt-get 方式安装sudo apt-get install libglfw3-dev4.官方提供了 qt 和 cmake 来编译文件，这里选择使用 cmake 方式编译mkdir buildcd build这里将例程程序的编译也打开，方便安装完成后直接查看视频。cmake .. -DBUILD_EXAMPLES:BOOL=true安装路径在/usr/local/lib ,头文件在/usr/local/includemake &amp;amp;&amp;amp; sudo make instal例程的执行程序在build/examples下##Video4Linux backend 安装 1.确保没有摄像头插上系统，注意拔出所有摄像头。 2.安装udve rules返回源码目录，运行sudo cp config/99-realsense-libusb.rules /etc/udev/rules.d/sudo udevadm control --reload-rules &amp;amp;&amp;amp; udevadm trigger3.根据自己系统选择相应的方式选择安装版本。由于我的系统是 Ubuntu16.04，内核为 4.4（uname –a命令查看系统和内核版本）./scripts/patch-uvcvideo-16.04.simple.sh这一步要经过漫长的安装。。。 4.重载 uvcvideo 驱动sudo modprobe uvcvideo5.查看安装信息的最后 50 行，应该可以看到一个新的 uvcvideo 驱动被安装sudo dmesg | tail -n 50运行后提示：（部分） Bluetooth: BNEP (Ethernet Emulation) ver 1.3[ 34.033878] Bluetooth: BNEP filters: protocol multicast[ 34.033885] Bluetooth: BNEP socket layer initialized[ 39.136255] IPv6: ADDRCONF(NETDEV_UP): wlp1s0: link is not ready[ 39.136424] iwlwifi 0000:01:00.0: L1 Disabled - LTR Disabled[ 39.136685] iwlwifi 0000:01:00.0: L1 Disabled - LTR Disabled[ 39.272219] iwlwifi 0000:01:00.0: L1 Disabled - LTR Disabled[ 39.272483] iwlwifi 0000:01:00.0: L1 Disabled - LTR Disabled[ 39.279661] mmc0: Got data interrupt 0x00000002 even though no data operation was in progress.[ 39.341626] IPv6: ADDRCONF(NETDEV_UP): wlp1s0: link is not ready[ 43.965760] IPv6: ADDRCONF(NETDEV_UP): wlp1s0: link is not ready[ 48.638656] wlp1s0: authenticate with b0:95:8e:89:3a:0f[ 48.640376] wlp1s0: send auth to b0:95:8e:89:3a:0f (try 1/3)[ 48.756518] wlp1s0: send auth to b0:95:8e:89:3a:0f (try 2/3)[ 48.758473] wlp1s0: authenticated[ 48.761946] wlp1s0: associate with b0:95:8e:89:3a:0f (try 1/3)[ 48.766951] wlp1s0: RX AssocResp from b0:95:8e:89:3a:0f (capab=0x431 status=0 aid=8)[ 48.768057] wlp1s0: associated[ 48.768117] IPv6: ADDRCONF(NETDEV_CHANGE): wlp1s0: link becomes ready[ 49.063317] iwlwifi 0000:01:00.0: No association and the time event is over already…[ 49.064030] wlp1s0: Connection to AP b0:95:8e:89:3a:0f lost[ 64.507052] Bluetooth: RFCOMM TTY layer initialized[ 64.507067] Bluetooth: RFCOMM socket layer initialized[ 64.507076] Bluetooth: RFCOMM ver 1.11[ 73.308219] wlp1s0: authenticate with b0:95:8e:89:3a:0f[ 73.309839] wlp1s0: send auth to b0:95:8e:89:3a:0f (try 1/3)[ 73.312326] wlp1s0: authenticated[ 73.313219] wlp1s0: associate with b0:95:8e:89:3a:0f (try 1/3)[ 73.319809] wlp1s0: RX AssocResp from b0:95:8e:89:3a:0f (capab=0x431 status=0 aid=8)[ 73.321144] wlp1s0: associated[ 75.552939] EXT4-fs (mmcblk1p3): recovery complete[ 75.552950] EXT4-fs (mmcblk1p3): mounted filesystem with ordered data mode. Opts: (null)[ 251.938597] media: Linux media interface: v0.10[ 251.962588] Linux video capture interface: v2.00[ 252.051084] usbcore: registered new interface driver uvcvideo[ 252.051089] USB Video Class driver (1.1.1)到此为止，安装驱动过程已经全部完成，插上摄像头，运行 build/examples 下的文件即可看到效果./cpp-capture尝试运行其他程序得到相应的结果：##遇到的问题安装完成后，使用 PC 上的虚拟机远程连接 turtlebot3 运行例子并不管用，即使开启了使用虚拟机桌面的权限也没法运行起来，而且有时出现找不到设备的情况，然后当使用 turtlebot3 插上 mirco HDMI 线，使用显示屏开机时，发现一切正常，欣喜若狂啊，猜测它应该是要求系统加载桌面才能跑通 demo，因为即使说 turtlebot3 开机了，但是在开机的时候没有连接 HDMI 线，开机完成才连接，也没法完整运行例子程序，老是显示找不到设备。除此之外，turtlebor3 无缘无故”死机”的问题还没解决.##思考现在仅仅是实现了一个 demo，能否用它来实现一个小小的项目或者一些有意思的事情呢，目前因为对摄像头还不是很了解，也不知道其具体的应用方向，在想能否在 turtlebot3 上用它来实现 vslam，实现真正的自主导航！##下一步用 ROS 启动摄像头##参考网站CSDN blogintel githubintel installation guide" }, { "title": "深度学习服务器搭建环境记录", "url": "/posts/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83%E8%AE%B0%E5%BD%95/", "categories": "机器学习", "tags": "", "date": "2020-01-30 21:35:32 +0800", "snippet": "下载 anacondaanaconda 的安装比较简单，参考官方文档的安装即可，可以通过 Linux 下 wget 命令下载 anaconda 安装包，官网安装包下载比较慢，推荐使用清华开源软件镜像站下载，注意需要下载的版本要和 python 的版本对应，我想使用 python3.6，故而下载的是 anaconda5.2.0,当然，也可以下载最新的 anaconda 版本，再通过创建虚拟环境来安装想要的 python 版本都可以。下载完直接使用bash bash Anaconda3-5.2.0-Linux-x86_64.sh命令安装即可，注意选择安装位置。配置环境添加镜像源由于 anaconda 源在国外，访问速度可能很慢，可以添加清华镜像源，能够使下载安装包的速度大大提高。操作非常简单，在 anaconda prompt 中输入conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/conda config --set show_channel_urls yes创建虚拟环境可以通过网络搜索得到 anaconda 创建环境的命令为：conda create --name env_zh python=3.6也可以通过命令 conda -h 或 conda create -h 来查看 conda 自带的帮助手册，自带的帮助说明比网上搜索到的更加详细。还可以通过来常用的命令如下conda -h : anaconda自带的帮助命令，很实用，网上搜索到的很多都不详细conda create -h 创建虚拟环境时的帮助命令，网上搜索不到时很有用conda create --name env_zh --clone old_env复制或克隆环境，可以复制已经搭建好的环境conda env list：查看现有的环境列表conda-env remove -n test2 删除 test2 虚拟环境conda activate env_zh 切换到 env_zh 虚拟环境conda deactivate 退出虚拟环境conda serach tensorflow-gpu搜索 tensorflow-GPU 的安装包，可以看到有多个版本的安装包安装 tensorflow-GPUconda install tensorflow-GPU=1.4: 由于服务器上面已经安装了 CUDA，并且版本为 CUDA8，最高只支持tensorflow1.4，如下图所示，1.4 版本的 tensorflowGPU 支持 3.6python 以及 6 版本的 cuDNN除此之外，其他和 tensorflow 有关的常用命令如下：cat /usr/local/cuda/version.txt ： 查看 CUDA 版本的命令cat /usr/local/cuda/include/cudnn.h | grep CUDNN_MAJOR -A 2 查看 cudnn 版本命令watch nvidia-smi 实时查看当前 GPU 显存占用率windows 上使用服务器上的 jupyter notebook在 windows 上使用 Linux 上的虚拟环境的 jupyter notebook首先要保证在同一个局域网，Linux 上装好 anaconda，然后创建虚拟环境 env_zh,切换到虚拟环境第一种方法 安装牛逼 conda 包即可，conda install nb_conda，安装完这个包，在当前环境下再次启动 jupyter notebook 就可以看到所有环境都显示出来了。第二种方法 如果该方法不行，可以通过 jupyter 插件手动解决，激活环境或，安装 kpykernelconda activate env_zhconda install ipykernelpython -m ipykernel install --name env_zh --display-name python env_zh启动之后根据提示给的网址在 windows 上登录即可，注意将 ip 地址改为服务器的 ip 地址即可。在 windows 上使用 vscode 同步代码到 Linux 上运行参考微软官方教程，其实很简单，只需要在服务器上安装 ssh server，在 vscode 中安装远程开发包，然后通过 ip 地址远程连接就可以了。我没有去弄远程调试功能，因为比较麻烦，在服务器命令行中直接使用 python 运行就可以了。虽然官方教程显示远程开发环境搭建需要 Ubuntu16.04 及以上，但是我使用 Ubuntu14.04 也能够安装成功。测试 GPU 是否可用在服务器上启动 jupyter server，在 windows 上登录网址，通过运行以下代码可以测试安装 GPU 版本的 tensorflow 是否成功import tensorflow as tfsess = tf.Session(config=tf.ConfigProto(log_device_placement=True))如果成功，会显示一个 CPU 和 GPU 的信息，我的是显示有 1 个 CPU 和两个 GPU。在服务器上使用后台运行代码如果通过 putty 连接服务器来运行代码时，当连接断掉会自动停止，可以让代码在后台运行，这样就可以一直跑程序了。参考windows 与 Linux 系统之间的文件互相转移当在 Ubuntu 上搭建好了深度学习环境，有时数据集在 windows 上，如何将数据集转移到服务器上呢？用 U 盘比较麻烦，这里通过使用共享 windows 文件，然后在 Linux 上挂载文件就可以实现在 Linux 上访问 windows 文件夹的方法了。 具体方法是，首先找到要共享的文件夹，在属性中添加共享，并开启网络发现，在一个局域网中，Linux 通过命令挂载登录到 windows 上的共享文件夹即可成功实现。 参考网上教程。环境搭建感悟： ensorflow 版本要和 cuda 和驱动版本对应，要不然无法正确使用 GPU，另外 tensorflow 有 GPU 版本，不能两个一起安装，否则会使用 CPU 版本的。 查看 GPU 使用情况 watch nvidia-smi 通过 jupyter notebook 可以远程写代码，通过 vscode 使用 ssh 可以远程调试和编辑 python 代码。 win10 挂载共享文件可以使在 Linux 上访问 Windows 文件夹。 充分使用 conda 的虚拟环境，可以省很多事情，有时候我们很多时候都把时间浪费到搭建环境中去了，都没有真正的关注深度学习这件事情本身。" }, { "title": "ResNet笔记(Deep Residual Learning for Image Recognition)", "url": "/posts/ResNet%E7%AC%94%E8%AE%B0-Deep-Residual-Learning-for-Image-Recognition/", "categories": "深度学习", "tags": "ResNet", "date": "2020-01-30 20:28:34 +0800", "snippet": "ResNet(Deep Residual Learning for Image Recognition)概述2015 年，由微软亚洲研究院何凯明等人发表的 ResNet 网络，成功的将网络层数加到更深的层次，并且获得了很好的效果，其复杂度也与之前的 vgg 网络相差不大，并且获得到了 ILSVRC 2015 和 COCO 2015 的分类任务竞赛冠军，同样也在 CIFAR-10 数据集上进行了 100 到 1000 层的测试。问题的提出 Fig.1 深层网络误差更大的现象是否越深的网络学习的就会更好？如上图所示，作者在 CIFAR-10 数据集上进行实验，发现 56 层的网络无论是在训练误差还是在测试误差上效果都比 20 层网络的效果差，这说明并不是越深的网络效果就会越好，因为深层网络带来梯度消失或者爆炸问题，导致深层网络的误差加大，一些现在已有的常用的方法是使用正则化初始化和中间初始化来解决，而当随着网络层数的加深，精度达到饱和的时候，继续进行训练精度反而快速下降，这种现象并不是因为过拟合导致的，论文给出猜想，添加一层额外的恒等映射，如下图所示：&amp;lt;img src=https://img-blog.csdnimg.cn/20191222194635612.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxOTA0MzA1MTU5,size_16,color_FFFFFF,t_70 alt=&quot;ResNet提出的剩余/残差学习模块&quot; width=&quot;60%&quot; height=&quot;60%&quot; /&amp;gt;Fig.2 ResNet 提出的剩余/残差学习模块这就是论文一开始提出 ResNet 模块，论文中提到了还有很多和短连接相关的工作，这里的短连接就是恒等映射，然后将输出加上叠层网络，最后输出的就是$F(x)+x$了。然后提出了 ResNet 有 2 个优点： 容易优化，其他建档叠加网络层数有很大的训练误差，也就是下图中所表现的 20 层和 56 层的训练误差 比之前的网络如 vgg 能够获得更高的精度作者使用该网络效果比 vgg 好，在 ImageNet 中误差率低，并在 ILSVRC2015 和 ImageNet 检测，定位和 COCO 分割竞赛中都获得了第一名，说明该网路确实是有很好的效果的。网络结构论文中提出了 2 种网络结构，一种是 plain 也就是原始的网络，另外一种是加上剩余学习或者叫做残差模块的残差网络，他们的网络结构如下表：![在这里插入图片描述])&amp;lt;img src=https://img-blog.csdnimg.cn/20191222194733313.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxOTA0MzA1MTU5,size_16,color_FFFFFF,t_70 alt=&quot;vgg19，plain34和ResNet34网络结构&quot; width=&quot;60%&quot; height=&quot;60%&quot; /&amp;gt;Fig.3 ResNet 提出的剩余/残差学习模块从左到右依次是 vgg19，plain，和 resnet，每种网络都包含了 4 个模块，经过每个模块的池化之后，分别缩小到原图的 1/2, 1/4, 1/8, 1/16 大小,每个模块都包含不同数量的卷积层数，而 34 层的 ResNet 特殊的一点就是加入了短连接，也就是图中曲线部分。plain 网络的想法来自于 vggnet，卷积层大多使用 3x3 的滤波器，然后遵循两条规则： 对输出相同的特征图大小，网络有相同数量的滤波器 如果特征图大小减半，滤波器数量加倍来保留每层网络的时间复杂度(这样为何可以保留时间复杂度？？)实施细节在 ImageNet 上的实现细节是跟着 vgg 论文来的。 数据增强： random crop 224x224, horizontal flip,per-pixel mean subtracted，标准色彩增强(standard color augmentation) 在卷积层激活函数层之间添加 BatchNormalization 初始化权重(来自于：Delving deep into rectifers: Surpassing human-level performance on imagenet classifcation) 优化器: SGD mini-batch: 256 learning rate: 从 0.1 开始当误差停止时减小 10 倍 迭代次数：600K, 迭代次数太多啦。。。 weight decay: 0.0001 momentum: 0.9 没有用到 dropout下图中左侧为 18 层和 34 层的 plain 网络的训练和验证误差，这里就有了退化问题，即 34 层的网络比 18 层网络的误差率更高，作者明确说明这种优化困难不是梯度消失造成的，因为 plain 网络已经使用 BN 进行了训练，确保了网络前向传播信号具有非 0 的方差，作者推测这是因为网络收敛速度极低，影响到了训练误差。而下图中右侧为 18 层和 34 层的 ResNet 的训练和验证误差，作者提到从该图中可以观测到 3 点： 残差学习可以扭转这种局面，34 层网络比 18 层网络误差更小，比 plain 网络有明显的区别，而且 34 层 ResNet 在验证数据上更好，表明 ResNet 可以很好的解决退化问题。 和 plain 的 34 层网络相比，ResNet34 获得了更小的训练误差，表明了残差系统可以在极深的系统中学习 和 palin 的 18 层网络相比，ResNet18 学习的更好，这说明了当网络没有那么深的时候(这里是 18 层),当前的 SGD 优化器仍然可以找到很好的解决方案，在这种情况下，ResNet 通过更快的收敛来简化优化。Fig.4 Plain 和 ResNet 网络在 ImageNet 上的训练和验证误差---ImageNet 中的结果，误差率如下图：Fig.5 plain 和 ResNet 在 ImageNet 中的误差率---到此为止已经说明了 ResNet 的优势所在了，作者又提出了另一种 ResNet 模块，Bottleneck ResNet，和之前的 buildingResNet 一样，只不过多增加了一层卷积层，该模块用于 ResNet-50/101/152,如下图所示：Fig.6 Building ResNet 和 Bottleneck ResNet---其中的 ResNet101 和 ResNet152 具体网络结构如下图所示：Fig.7 ResNet 在 ImageNet 上的具体网络架构" } ]
